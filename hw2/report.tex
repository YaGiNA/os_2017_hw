\documentclass[11pt,a4paper, uplatex]{jsarticle}
%
\usepackage{amsmath,amssymb}
\usepackage{bm}
\usepackage[dvipdfmx]{graphicx}
\usepackage{ascmac}
\usepackage{listings}
\usepackage{underscore}
\lstset{
    frame=single,
    numbers=left,
    tabsize=2
}
%
\setlength{\textwidth}{\fullwidth}
\setlength{\textheight}{40\baselineskip}
\addtolength{\textheight}{\topskip}
\setlength{\voffset}{-0.2in}
\setlength{\topmargin}{0pt}
\setlength{\headheight}{0pt}
\setlength{\headsep}{0pt}
%
\newcommand{\divergence}{\mathrm{div}\,}  %ダイバージェンス
\newcommand{\grad}{\mathrm{grad}\,}  %グラディエント
\newcommand{\rot}{\mathrm{rot}\,}  %ローテーション
%
\title{OS 第2回課題レポート}
\author{1510151  栁 裕太}
\date{\today}
\begin{document}
\maketitle
\section{課題1: 和訳}

\subsection{デッドロックの条件}
4つの条件がデッドロック発生を引き起こす。[C+71]

\begin{itemize}
  \item \textbf{相互排除:} 複数スレッドが必要なリソースの排他制御を要求するとき
  (例: 単一スレッドがロックの所有権を獲得する)

  \item \textbf{保持\&待ち:} 複数スレッドが追加リソースを待つ間に、
  (例: これが、彼らがリソースの獲得を望んでいるように見える)
  割り当てられたリソースを保持する
  (例: これが、彼らが既にリソースを獲得したもののように見える)

  \item \textbf{先取なし:} 複数リソース(例: ロック)を、
  所有されているスレッドから強制消去することができない

  \item \textbf{循環待機:}
  次のスレッドが必要としている、1つあるいはそれ以上のリソース(例: ロック)
  を持つスレッドらによる、循環連鎖が存在する
\end{itemize}

もしも4つのうちいずれかのの条件に出くわしていないのなら、
デッドロックは発生することができない。
それゆえ、我々はまずデッドロックを回避する技術調べる…
これらの各戦術が、これらの条件の1つを発生から回避することを求めており、
それゆえ、これが1つのデッドロック問題に対する対応方法となっている。

\subsection{防止策}
\subsubsection{循環待機}
概ね、多くの実践的な防止技術(そして、確かにその1つはよく採用されている)は、
あなたに循環待機を決して引き起こさないようなロックするコードを書かせるだろう。
最もわかりやすくそれを遂行する方法は、たった2つのロックを取り入れたシステム(L1とL2)で、
あなたは常にL1がL2の前に獲得させることで、デッドロックを防止することができる。
厳格な順番こそが、環状待機発生なしを確証させ、それこそがデッドロックなしとなる。

もちろんのこと、更に複雑なシステム内では、2つ以上のロックが存在するだろうし、
またゆえに全体のロックの順序も達成
は難しくなるかもしれない(そしてあるいは不要なのかもしれないのはさておき)。
それゆえ、\textbf{部分配列}はデッドロックを回避するための、
ロック獲得構造を使いやすい方法になりえるのである。
1つの素晴らしい部分ロック順の現実の例はLinux[T+94]における、
メモリマッピングコードにて閲覧可能であり、ソースコード上部のコメントには、
10の異なるロック獲得順のグループを明らかにしており、
"\texttt{i_mmap_mutex}の前に\texttt{i_mmap}"のようなシンプルな1つや
"\texttt{mapping-\textgreater tree_lock}の前に\texttt{swap_lock}の前に
\texttt{private_lock}の前に\texttt{i_mmap_mutex}"
のようなより複雑な順序を含んでいる。

あなたが想像できるように、
双方の全体と一部の獲得順はロックを行う戦術における慎重なデザインであり、
また念入りな注意によって構築されなければならない。
更に言えば、順番はたかが慣習であり、
また杜撰なプログラマーは簡単にプロトコルをロックすることを無視し、
そしてデッドロックを引き起こす可能性もありえる。
最終的に、ロック順はコードベースと、そしていかに多くのルーチンが呼び出されるか…
における深い理解必要とし、たった1つのミスが"D"(Deadlockの象徴)の世界に入る結果に終わる。

\subsubsection{保持\&待ち}
デッドロックにおける保持\&待ちの条件は、
すべてのロックを1度獲得することで回避することができる、原始的だが。
実践では、これは以下のコードで達成することが可能である。
\begin{lstlisting}
  pthread_mutex_lock(prevention);   // begin lock acquistion
  pthread_mutex_lock(L1);
  pthread_mutex_lock(L2);
  ...
  pthread_mutex_unlock(prevention); // end
\end{lstlisting}

最初の\texttt{prevention}ロックを獲得することで、
このコードは中央のロック獲得や、
そしてそれによるデッドロックがが再発することが引き起こしかねない
時期尚早なスレッド切替ががないことを確約し、防ぐ。
もちろんのこと、これはいつでもどのスレッドがロックを獲得することを要求し、
それが最初に得るグローバル防止ロックとなる。
例えば、もし別のスレッドがロック\texttt{L1}と\texttt{L2}を、
それぞれ別の順で獲得しようとした時、
問題はない、何故ならばこれは防止ロックを実行中に保持しているためである。

ここで留意すべきは、この解決策は多数の理由において問題があることだ。
従来では、作品を我々とは反対にカプセル化した…ルーチンが呼ばれた時、
このアプローチは我々に、
まさにどのロックが保持されそして獲得するかを前もって知ることを要求する。
この技術はまた、彼らが本当に必要とされたときに代わって、
すべての早い段階(一度)で獲得されなければならないロックの同時並行性を落としそうなのである。
\end{document}
